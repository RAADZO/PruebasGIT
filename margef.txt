Option Explicit

Public Sub ReportePorCadaID_BloquesTablas_SoloGuionBajo_FIX()
    Dim wb As Workbook: Set wb = ThisWorkbook
    Dim wsParam As Worksheet
    Dim ids As Object
    Dim lastRow As Long, i As Long, idTxt As String

    On Error Resume Next
    Set wsParam = wb.Worksheets("Parametros")
    On Error GoTo 0

    If wsParam Is Nothing Then
        MsgBox "No existe la hoja 'Parametros'. Pon los IDs en A2:A.", vbExclamation
        Exit Sub
    End If

    Set ids = CreateObject("Scripting.Dictionary")
    ids.CompareMode = 1 ' vbTextCompare

    lastRow = wsParam.Cells(wsParam.Rows.Count, "A").End(xlUp).Row
    If lastRow < 2 Then
        MsgBox "No hay IDs en 'Parametros' (A2:A).", vbExclamation
        Exit Sub
    End If

    For i = 2 To lastRow
        idTxt = CleanHeaderText(wsParam.Cells(i, "A").Value)
        If idTxt <> "" Then
            If Not ids.Exists(idTxt) Then ids.Add idTxt, True
        End If
    Next i

    If ids.Count = 0 Then
        MsgBox "No se cargó ningún ID válido.", vbExclamation
        Exit Sub
    End If

    Application.ScreenUpdating = False
    Application.EnableEvents = False

    Dim k As Variant
    For Each k In ids.Keys
        GenerarReporteParaUnID_FIX CStr(k), wsParam, wb
    Next k

    Application.EnableEvents = True
    Application.ScreenUpdating = True

    MsgBox "Listo. Se generaron " & ids.Count & " reportes (1 por ID).", vbInformation
End Sub


Private Sub GenerarReporteParaUnID_FIX(ByVal theID As String, ByVal wsParam As Worksheet, ByVal wb As Workbook)
    Dim wsOut As Worksheet
    Dim reportName As String
    reportName = MakeSafeSheetName("RPT_" & theID)

    Set wsOut = GetOrCreateSheet(wb, reportName)
    wsOut.Cells.Clear

    wsOut.Cells(1, 1).Value = "Report for ID:"
    wsOut.Cells(1, 2).Value = theID
    wsOut.Rows(1).Font.Bold = True

    Dim outRow As Long: outRow = 3

    Dim ws As Worksheet, lo As ListObject
    Dim idCol As Long, c As Long, r As Long
    Dim colsToExport As Collection
    Dim hasAnyUnderscore As Boolean
    Dim matchCount As Long
    Dim outCol As Long
    Dim colIdx As Variant
    Dim idVal As String
    Dim hdr As String, headerOut As String

    For Each ws In wb.Worksheets
        If ws.Name <> wsParam.Name And ws.Name <> wsOut.Name Then

            For Each lo In ws.ListObjects
                If lo.DataBodyRange Is Nothing Then GoTo NextTable

                idCol = FindIDColumnIndex(lo) ' <-- robusto
                If idCol = 0 Then GoTo NextTable

                ' Columnas a exportar: ID + columnas cuyo header empieza por "_"
                Set colsToExport = New Collection
                colsToExport.Add idCol
                hasAnyUnderscore = False

                For c = 1 To lo.ListColumns.Count
                    If c <> idCol Then
                        hdr = GetHeaderText(lo, c)   ' <-- robusto
                        If StartsWithUnderscore(hdr) Then
                            colsToExport.Add c
                            hasAnyUnderscore = True
                        End If
                    End If
                Next c

                If Not hasAnyUnderscore Then GoTo NextTable

                ' Contar filas que matchean el ID
                matchCount = 0
                For r = 1 To lo.DataBodyRange.Rows.Count
                    idVal = CleanHeaderText(lo.DataBodyRange.Cells(r, idCol).Value)
                    If StrComp(idVal, theID, vbTextCompare) = 0 Then matchCount = matchCount + 1
                Next r

                If matchCount = 0 Then GoTo NextTable

                ' Título bloque
                wsOut.Cells(outRow, 1).Value = "Sheet: " & ws.Name & " | Table: " & lo.Name & " | Matches: " & matchCount
                wsOut.Cells(outRow, 1).Font.Bold = True
                outRow = outRow + 1

                ' Headers del bloque (AHORA sí: de cada tabla)
                outCol = 1
                For Each colIdx In colsToExport
                    hdr = GetHeaderText(lo, CLng(colIdx))
                    headerOut = hdr
                    ' Quita "_" en el reporte para que quede limpio (si quieres conservarlo, comenta esta línea)
                    If StartsWithUnderscore(headerOut) Then headerOut = Mid$(CleanHeaderText(headerOut), 2)

                    wsOut.Cells(outRow, outCol).Value = headerOut
                    wsOut.Cells(outRow, outCol).Font.Bold = True
                    outCol = outCol + 1
                Next colIdx
                outRow = outRow + 1

                ' Filas del bloque
                For r = 1 To lo.DataBodyRange.Rows.Count
                    idVal = CleanHeaderText(lo.DataBodyRange.Cells(r, idCol).Value)
                    If StrComp(idVal, theID, vbTextCompare) = 0 Then
                        outCol = 1
                        For Each colIdx In colsToExport
                            wsOut.Cells(outRow, outCol).Value = lo.DataBodyRange.Cells(r, CLng(colIdx)).Value
                            outCol = outCol + 1
                        Next colIdx
                        outRow = outRow + 1
                    End If
                Next r

                outRow = outRow + 2 ' 2 filas en blanco entre tablas

NextTable:
            Next lo
        End If
    Next ws

    wsOut.Columns.AutoFit
End Sub


' ===== Helpers robustos =====

' Devuelve el texto del encabezado: primero HeaderRowRange, si no ListColumns.Name
Private Function GetHeaderText(ByVal lo As ListObject, ByVal colIndex As Long) As String
    Dim h As String
    h = ""

    On Error Resume Next
    h = CStr(lo.HeaderRowRange.Cells(1, colIndex).Value)
    On Error GoTo 0

    h = CleanHeaderText(h)

    If h = "" Then
        h = CleanHeaderText(lo.ListColumns(colIndex).Name)
    End If

    GetHeaderText = h
End Function

' Encuentra columna ID buscando por ambas fuentes
Private Function FindIDColumnIndex(ByVal lo As ListObject) As Long
    Dim c As Long, h As String
    FindIDColumnIndex = 0

    For c = 1 To lo.ListColumns.Count
        h = GetHeaderText(lo, c)
        If StrComp(h, "ID", vbTextCompare) = 0 Then
            FindIDColumnIndex = c
            Exit Function
        End If
    Next c
End Function

' Limpia espacios y caracteres invisibles comunes
Private Function CleanHeaderText(ByVal v As Variant) As String
    Dim s As String
    s = Trim$(CStr(v))

    ' quitar NBSP (char 160) y tab/saltos
    s = Replace(s, ChrW(160), " ")
    s = Replace(s, vbTab, " ")
    s = Replace(s, vbCr, " ")
    s = Replace(s, vbLf, " ")

    ' compactar dobles espacios
    Do While InStr(s, "  ") > 0
        s = Replace(s, "  ", " ")
    Loop

    CleanHeaderText = Trim$(s)
End Function

Private Function StartsWithUnderscore(ByVal s As String) As Boolean
    s = CleanHeaderText(s)
    StartsWithUnderscore = (Len(s) > 0 And Left$(s, 1) = "_")
End Function

Private Function GetOrCreateSheet(ByVal wb As Workbook, ByVal sheetName As String) As Worksheet
    On Error Resume Next
    Set GetOrCreateSheet = wb.Worksheets(sheetName)
    On Error GoTo 0

    If GetOrCreateSheet Is Nothing Then
        Set GetOrCreateSheet = wb.Worksheets.Add(After:=wb.Worksheets(wb.Worksheets.Count))
        GetOrCreateSheet.Name = sheetName
    End If
End Function

Private Function MakeSafeSheetName(ByVal s As String) As String
    Dim badChars As Variant, ch As Variant
    badChars = Array(":", "\", "/", "?", "*", "[", "]")

    For Each ch In badChars
        s = Replace(s, CStr(ch), "_")
    Next ch

    s = Trim$(s)
    If Len(s) = 0 Then s = "RPT"
    If Len(s) > 31 Then s = Left$(s, 31)

    MakeSafeSheetName = s
End Function